// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.

#include "leveldb/filter_policy.h"
#include <stdio.h>
#include "leveldb/slice.h"
#include "util/hash.h"
#include <list>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include "leveldb/env.h"
#include "leveldb/threadpool.h"
#include "util/threadpool_imp.h"
#include "leveldb/statistics.h"
#include "util/coding.h"
#include <unistd.h>
#define handle_error_en(en, msg) \
	do                           \
	{                            \
		errno = en;              \
		perror(msg);             \
		exit(EXIT_FAILURE);      \
	} while (0)

namespace leveldb
{

namespace
{
static uint32_t BloomHash(const Slice &key, int id)
{
	switch (id)
	{
	case 0:
		return Hash(key.data(), key.size(), 0xbc9f1d34);
	case 1:
		return Hash(key.data(), key.size(), 0x34f1d34b);
	case 2:
		return Hash(key.data(), key.size(), 0x251d34bc);
	case 3:
		return Hash(key.data(), key.size(), 0x01d34bc9);
	case 4:
		return Hash(key.data(), key.size(), 0x1934bc9f);
	case 5:
		return Hash(key.data(), key.size(), 0x934bc9f1);
	case 6:
		return Hash(key.data(), key.size(), 0x4bc9f193);
	case 7:
		return Hash(key.data(), key.size(), 0x51c2578a);
	case 8:
		return Hash(key.data(), key.size(), 0xda23562f);
	case 9:
		return Hash(key.data(), key.size(), 0x135254f2);
	case 10:
		return Hash(key.data(), key.size(), 0xea1e4a48);
	case 11:
		return Hash(key.data(), key.size(), 0x567925f1);
	default:
		handle_error_en(1, "BloomHash id error");
	}
}

class TraditionalBloomFilterPolicy : public FilterPolicy
{
private:
	size_t bits_per_key_;
	size_t k_;
	int id_; //begin from 0
public:
	explicit TraditionalBloomFilterPolicy(int bits_per_key, int id)
		: bits_per_key_(bits_per_key), id_(id)
	{
		// We intentionally round down to reduce probing cost a little bit
		k_ = static_cast<size_t>(bits_per_key * 0.69); // 0.69 =~ ln(2)
		if (k_ < 1)
			k_ = 1;
		if (k_ > 30)
			k_ = 30;
	}

	virtual const char *Name() const
	{
		return "leveldb.BuiltinBloomFilter2";
	}

	virtual void CreateFilter(const Slice *keys, int n, std::string *dst) const
	{
		// Compute bloom filter size (in both bits and bytes)
		size_t bits = n * bits_per_key_;

		// For small n, we can see a very high false positive rate.  Fix it
		// by enforcing a minimum bloom filter length.
		if (bits < 64)
			bits = 64;

		size_t bytes = (bits + 7) / 8;
		bits = bytes * 8;

		const size_t init_size = dst->size();
		dst->resize(init_size + bytes, 0);
		dst->push_back(static_cast<char>(k_)); // Remember # of probes in filter
		char *array = &(*dst)[init_size];
		for (int i = 0; i < n; i++)
		{
			// Use double-hashing to generate a sequence of hash values.
			// See analysis in [Kirsch,Mitzenmacher 2006].
			uint32_t h = BloomHash(keys[i], id_);
			const uint32_t delta = (h >> 17) | (h << 15); // Rotate right 17 bits
			for (size_t j = 0; j < k_; j++)
			{
				const uint32_t bitpos = h % bits;
				h += delta;
				array[bitpos / 8] |= (1 << (bitpos % 8));
			}
		}
	}

	virtual void CreateFilter(const Slice *keys, int n, std::list<std::string> &dsts) const
	{
		return;
	}

	virtual bool KeyMayMatchFilters(const Slice &key, const std::list<leveldb::Slice> &filters) const
	{
		return true;
	}

	virtual bool KeyMayMatch(const Slice &key, const Slice &bloom_filter) const
	{
		const size_t len = bloom_filter.size();
		if (len < 2)
			return false;

		const char *array = bloom_filter.data();
		const size_t bits = (len - 1) * 8;

		// Use the encoded k so that we can read filters generated by
		// bloom filters created using different parameters.
		const size_t k = array[len - 1];
		if (k > 30)
		{
			// Reserved for potentially new encodings for short bloom filters.
			// Consider it a match.
			return true;
		}

		uint32_t h = BloomHash(key, id_);
		const uint32_t delta = (h >> 17) | (h << 15); // Rotate right 17 bits
		for (size_t j = 0; j < k; j++)
		{
			const uint32_t bitpos = h % bits;
			h += delta;
			if ((array[bitpos / 8] & (1 << (bitpos % 8))) == 0)
				return false;
		}
		return true;
	}

	virtual int filterNums() const
	{
		return 1;
	}
};

#define LOG2_CACHE_LINE_BYTES 6
#define CACHE_LINE_SIZE (1 << LOG2_CACHE_LINE_BYTES)
#define PREFETCH(addr, rw, locality) __builtin_prefetch(addr, rw, locality)

class BlockedBloomFilterPolicy : public FilterPolicy
{
private:
	size_t bits_per_key_;
	size_t k_;
	int id_; //begin from 0
	const bool ExtraRotates = true;
public:
	explicit BlockedBloomFilterPolicy(int bits_per_key, int id)
		: bits_per_key_(bits_per_key), id_(id)
	{
		// We intentionally round down to reduce probing cost a little bit
		k_ = static_cast<size_t>(bits_per_key * 0.69); // 0.69 =~ ln(2)
		if (k_ < 1)
			k_ = 1;
		if (k_ > 30)
			k_ = 30;
	}

	virtual const char *Name() const
	{
		return "leveldb.BuiltinBlockedBloomFilter";
	}

	size_t GetTotalBitsForLocality(size_t total_bits) const
	{
		size_t num_lines =
			(total_bits + CACHE_LINE_SIZE * 8 - 1) / (CACHE_LINE_SIZE * 8);

		// Make num_lines an odd number to make sure more bits are involved
		// when determining which block.
		if (num_lines % 2 == 0)
		{
			num_lines++;
		}
		return num_lines * (CACHE_LINE_SIZE * 8);
	}

	inline uint32_t GetLine(uint32_t h, uint32_t num_lines) const {
		uint32_t offset_h = ExtraRotates ? (h >> 11) | (h << 21) : h;
		return offset_h % num_lines;
	}

	virtual void CreateFilter(const Slice *keys, int n, std::string *dst) const
	{
		// Compute bloom filter size (in both bits and bytes)
		size_t bits = GetTotalBitsForLocality(n * bits_per_key_);
		size_t bytes = bits / 8;
		size_t num_lines = bits / (CACHE_LINE_SIZE * 8);

		const size_t init_size = dst->size();
		dst->resize(init_size + bytes + 5, 0);
		char *array = &(*dst)[init_size];

		array[bytes] = static_cast<char>(k_);
		EncodeFixed32(array + bytes + 1, static_cast<uint32_t>(num_lines));

		for (int i = 0; i < n; i++)
		{
			uint32_t h = BloomHash(keys[i], id_);

			const int log2_cache_line_bits = LOG2_CACHE_LINE_BYTES + 3;

			char *data_at_offset =
				array + (GetLine(h, num_lines) << LOG2_CACHE_LINE_BYTES);
			const uint32_t delta = (h >> 17) | (h << 15);
			for (int i = 0; i < k_; ++i) {
				// Mask to bit-within-cache-line address
				const uint32_t bitpos = h & ((1 << log2_cache_line_bits) - 1);
				data_at_offset[bitpos / 8] |= (1 << (bitpos % 8));
				if (ExtraRotates) {
					h = (h >> log2_cache_line_bits) | (h << (32 - log2_cache_line_bits));
				}
				h += delta;
			}
		}
	}

	virtual void CreateFilter(const Slice *keys, int n, std::list<std::string> &dsts) const
	{
		return;
	}

	virtual bool KeyMayMatchFilters(const Slice &key, const std::list<leveldb::Slice> &filters) const
	{
		return true;
	}

	inline void PrepareHashMayMatch(uint32_t h, uint32_t num_lines,
									const char *data,
									uint32_t /*out*/ *byte_offset) const {
		uint32_t b = GetLine(h, num_lines) << LOG2_CACHE_LINE_BYTES;
		PREFETCH(data + b, 0 /* rw */, 1 /* locality */);
		PREFETCH(data + b + ((1 << LOG2_CACHE_LINE_BYTES) - 1), 0 /* rw */,
				1 /* locality */);
		*byte_offset = b;
	}

	inline bool HashMayMatchPrepared(uint32_t h, int num_probes,
                                          const char *data_at_offset) const {
		const int log2_cache_line_bits = LOG2_CACHE_LINE_BYTES + 3;

		const uint32_t delta = (h >> 17) | (h << 15);
		for (int i = 0; i < num_probes; ++i) {
			// Mask to bit-within-cache-line address
			const uint32_t bitpos = h & ((1 << log2_cache_line_bits) - 1);
			if (((data_at_offset[bitpos / 8]) & (1 << (bitpos % 8))) == 0) {
				return false;
			}
			if (ExtraRotates) {
				h = (h >> log2_cache_line_bits) | (h << (32 - log2_cache_line_bits));
			}
			h += delta;
		}
		return true;
	}

	virtual bool KeyMayMatch(const Slice &key, const Slice &bloom_filter) const
	{
		const size_t len = bloom_filter.size();
		if (len < 5)
			return false;

		const char *array = bloom_filter.data();
		const size_t bits = (len - 5) * 8;

		// Use the encoded k so that we can read filters generated by
		// bloom filters created using different parameters.
		const size_t k = array[len - 5];
		const size_t num_lines = DecodeFixed32(array + len - 4);
		if (k > 30)
		{
			// Reserved for potentially new encodings for short bloom filters.
			// Consider it a match.
			return true;
		}

		uint32_t h = BloomHash(key, id_);

		uint32_t byte_offset;
		PrepareHashMayMatch(h, num_lines, array, &byte_offset);
		return HashMayMatchPrepared(h, k, array + byte_offset);
	}

	virtual int filterNums() const
	{
		return 1;
	}
};

struct CreateFilterArg
{
	ChildPolicy *ch;
	std::string *dst;
};

class MultiFilter : public FilterPolicy
{
private:
	std::vector<ChildPolicy *> filters;
	size_t bits_per_key_;
	//	static pthread_mutex_t filter_mutexs_[10];
	//	static pthread_cond_t filter_conds_[10];
	static pthread_t pids_[16];
	static std::atomic<int> curr_completed_filter_num_;
	static int filter_num_;
	static std::atomic<bool> filled_[16];
	static const Slice *keys_;
	static int n_;
	static bool end_thread;

public: 
	static CreateFilterArg *cfas;
	static void *CreateFilter_T(void *arg)
	{
		int id = *(int *)(arg);
		delete (int *)(arg);
		CreateFilterArg *temp_cfa = cfas + id;
		while (true)
		{
			//	      pthread_mutex_lock(&filter_mutexs_[id]);
			while (!filled_[id] && !end_thread)
			{
				//		pthread_cond_wait(&filter_conds_[id],&filter_mutexs_[id]);
			}
			//	      pthread_mutex_unlock(&filter_mutexs_[id]);
			if (end_thread)
			{
				break;
			}
			uint64_t start_micros = Env::Default()->NowMicros();
			cfas[id].ch->CreateFilter(keys_, n_, cfas[id].dst);
			filled_[id] = false;
			MeasureTime(Statistics::GetStatistics().get(), Tickers::CHILD_CREATE_FILTER_TIME, Env::Default()->NowMicros() - start_micros);
			start_micros = Env::Default()->NowMicros();
			++curr_completed_filter_num_;
			MeasureTime(Statistics::GetStatistics().get(), Tickers::CHILD_FILTER_OTHER_TIME, Env::Default()->NowMicros() - start_micros);
		}
	}
	explicit MultiFilter(int bits_per_key_per_filter[], int bits_per_key) : bits_per_key_(bits_per_key)
	{
		int i;
		int cpu_count = sysconf(_SC_NPROCESSORS_CONF);
		int base_cpu_id = 8;
		int filter_nums = 0;

		bits_per_key_per_filter_ = new size_t[16]();
		char name_buf[24];
		end_thread = false;
		for (i = 0; bits_per_key_per_filter[i] != 0; i++)
		{
			ChildPolicy *ch_filter = new ChildPolicy(bits_per_key_per_filter[i], i);
			filters.push_back(ch_filter);
			bits_per_key_per_filter_[i] = bits_per_key_per_filter[i];
			filled_[i] = false;
			filter_nums++;
		}
		curr_completed_filter_num_ = 0;
		filter_num_ = i;
		printf("filters size:%ld\n", filters.size());
		cfas = new CreateFilterArg[filters.size()];
		i = 0;

	#ifdef ChildPolicy
		printf("Used ChildPolicy: %s\n", STR(ChildPolicy));
	#endif

		printf("FilterMergeThreshold: %d\n", FilterMergeThreshold);
		if (FilterMergeThreshold <= 1 || FilterMergeThreshold > filter_nums) {
			fprintf(stderr, "set FilterMergeThreshold error!\n");
			exit(1);
		}

		for (std::vector<ChildPolicy *>::const_iterator iter = filters.begin(); iter != filters.end(); iter++)
		{
			int *temp_id = new int(i);
			cpu_set_t cpuset;
			CPU_ZERO(&cpuset);
			CPU_SET(base_cpu_id + i, &cpuset);

			if (pthread_create(pids_ + i, NULL, MultiFilter::CreateFilter_T, (void *)(temp_id)) != 0)
			{
				perror("create thread ");
			}
			snprintf(name_buf, sizeof name_buf, "filter:bg%d", i);
			name_buf[sizeof name_buf - 1] = '\0';
			pthread_setname_np(pids_[i], name_buf);

			if (base_cpu_id + filters.size() < cpu_count)
			{
				int s = pthread_setaffinity_np(pids_[i], sizeof(cpu_set_t), &cpuset);
				if (s != 0)
				{
					handle_error_en(s, "pthread_setaffinity_np");
				}
			}

			cfas[i++].ch = *iter;
		}
	}

	virtual void CreateFilter(const Slice *keys, int n, std::string *dst) const
	{
		int i = 0;
		for (std::vector<ChildPolicy *>::const_iterator iter = filters.begin(); iter != filters.end(); iter++)
		{
			(*iter)->CreateFilter(keys, n, dst + i);
			i++;
		}
	}
	virtual void CreateFilter(const Slice *keys, int n, std::list<std::string> &dsts) const
	{
		CreateFilterArg *cfa = cfas;
		keys_ = keys;
		n_ = n;
		int i = 0;
		uint64_t start_micros = Env::Default()->NowMicros();
		for (auto dsts_iter = dsts.begin(); dsts_iter != dsts.end(); ++dsts_iter)
		{
			// pthread_mutex_lock(&filter_mutexs_[i]);
			cfa->dst = &(*dsts_iter);
			filled_[i] = true;
			// pthread_mutex_unlock(&filter_mutexs_[i]);
			// pthread_cond_signal(&filter_conds_[i++]);
			cfa++;
			i++;
		}
		MeasureTime(Statistics::GetStatistics().get(), Tickers::FILTER_LOCK_TIME, Env::Default()->NowMicros() - start_micros);
		start_micros = Env::Default()->NowMicros();
		while (curr_completed_filter_num_ != filter_num_)
			;
		MeasureTime(Statistics::GetStatistics().get(), Tickers::FILTER_WAIT_TIME, Env::Default()->NowMicros() - start_micros);
		curr_completed_filter_num_ = 0;
	}
	virtual bool KeyMayMatch(const Slice &key, const Slice &bloom_filter, int id) const
	{
		return filters[id]->KeyMayMatch(key, bloom_filter);
	}
	virtual bool KeyMayMatch(const Slice &key, const Slice &bloom_filter) const
	{
		return true;
	}
	virtual bool KeyMayMatchFilters(const Slice &key, const std::list<Slice> &filter_strs) const
	{
		std::vector<ChildPolicy *>::const_iterator filter_iter = filters.begin();
		for (std::list<Slice>::const_iterator filter_strs_iter = filter_strs.begin(); filter_strs_iter != filter_strs.end(); filter_strs_iter++)
		{
			if (!(*filter_iter)->KeyMayMatch(key, *filter_strs_iter))
			{
				return false;
			}
			filter_iter++;
		}
		return true;
	}

	virtual bool KeyMayMatchFilters(const Slice& key, const MultiFilters* multi_filters) const
	{
		std::vector<ChildPolicy *>::const_iterator filter_iter = filters.begin();

		if (!multi_filters->is_merged) {
			for (std::list<Slice>::const_iterator filter_strs_iter = multi_filters->separated_filters.begin(); filter_strs_iter != multi_filters->separated_filters.end(); filter_strs_iter++)
			{
				if (!(*filter_iter)->KeyMayMatch(key, *filter_strs_iter))
				{
					return false;
				}
				filter_iter++;
			}
		} else { //merged filters

		}

		return true;
	}

	virtual int filterNums() const override
	{
		return filters.size();
	}

	virtual const char *Name() const
	{
		return "leveldb.multi_bloom_filter";
	}

	virtual ~MultiFilter()
	{
		int i = 0;
		end_thread = true;
		for (auto iter = filters.begin(); !filters.empty();)
		{
			delete *iter;
			iter = filters.erase(iter);
			pthread_join(pids_[i++], NULL);
		}
		fprintf(stderr, "Multi_bloom_filter destructor is called\n");
	}
};

std::atomic<int> MultiFilter::curr_completed_filter_num_(0);
int MultiFilter::filter_num_ = 0;
// pthread_mutex_t MultiFilter::filter_mutexs_[10]={PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,};
// pthread_cond_t MultiFilter::filter_conds_[10]={PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER};
std::atomic<bool> MultiFilter::filled_[16];
pthread_t MultiFilter::pids_[16];
CreateFilterArg *MultiFilter::cfas(NULL);
int MultiFilter::n_(0);
const Slice *MultiFilter::keys_(NULL);
bool MultiFilter::end_thread(false);
} //anonymous namespace


MultiFilters::~MultiFilters() {

}

void MultiFilters::addFilter(Slice &contents) {
	if (!is_merged && !is_compressed) {
		separated_filters.push_back(contents);
		curr_num_of_filters++;

		if (curr_num_of_filters >= FilterMergeThreshold) {
			is_merged = true;
			merge();
		}
	} else { //merged filters
		//Waiting to be optimized
		separate();

		separated_filters.push_back(contents);
		curr_num_of_filters++;

		merge();
	}
}

void MultiFilters::removeFilter() {
	if (!is_merged && !is_compressed) {
		separated_filters.pop_back();
		curr_num_of_filters--;
	} else if (curr_num_of_filters == FilterMergeThreshold) {
		is_merged = false;
		separate();

		separated_filters.pop_back();
		curr_num_of_filters--;
	} else { //Waiting to be optimized
		separate();

		separated_filters.pop_back();
		curr_num_of_filters--;

		merge();
	}
}

void MultiFilters::merge() {

}

void MultiFilters::separate() {

}

void MultiFilters::push_back_merged_filters(const Slice &contents) {

}

void MultiFilters::pop_back_merged_filters() {
	
}

size_t *leveldb::FilterPolicy::bits_per_key_per_filter_ = nullptr;
const FilterPolicy *NewBloomFilterPolicy(int bits_per_key_per_filter[], int bits_per_key)
{
	return new MultiFilter(bits_per_key_per_filter, bits_per_key);
}
const FilterPolicy *NewBloomFilterPolicy(int *)
{
	return NULL;
}
const FilterPolicy *NewBloomFilterPolicy(int)
{
	return NULL;
}

} // namespace leveldb
